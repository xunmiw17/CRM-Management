package com.frank.crm.service;

import com.frank.crm.base.BaseService;
import com.frank.crm.dao.CustomerLossMapper;
import com.frank.crm.dao.CustomerMapper;
import com.frank.crm.dao.CustomerOrderMapper;
import com.frank.crm.query.CustomerQuery;
import com.frank.crm.utils.AssertUtil;
import com.frank.crm.utils.PhoneUtil;
import com.frank.crm.vo.Customer;
import com.frank.crm.vo.CustomerLoss;
import com.frank.crm.vo.CustomerOrder;
import com.github.pagehelper.PageHelper;
import com.github.pagehelper.PageInfo;
import org.apache.commons.lang3.StringUtils;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.Resource;
import java.util.*;

@Service
public class CustomerService extends BaseService<Customer, Integer> {

    @Resource
    private CustomerMapper customerMapper;

    @Resource
    private CustomerOrderMapper customerOrderMapper;

    @Resource
    private CustomerLossMapper customerLossMapper;

    /**
     * The method queries the customer by multiple conditions and finally splits the result into pages. The data
     * type to be returned must conform to what LayUI requires.
     * @param customerQuery
     * @return
     */
    public Map<String, Object> queryCustomerByParams(CustomerQuery customerQuery) {
        Map<String, Object> map = new HashMap<>();

        // Starts paging
        PageHelper.startPage(customerQuery.getPage(), customerQuery.getLimit());
        // Gets correspondent page object
        PageInfo<Customer> pageInfo = new PageInfo<>(customerMapper.selectByParams(customerQuery));

        map.put("code", 0);
        map.put("msg", "success");
        map.put("count", pageInfo.getTotal());
        map.put("data", pageInfo.getList());

        return map;
    }

    /**
     * Adds customer
     *      1. Check parameters
     *          customerName -> Not null, unique
     *          fr -> Not null
     *          phone -> right format
     *      2. Set default value
     *          isValid -> 1
     *          createDate -> current system time
     *          updateDate -> current system time
     *          khno -> generated by our system and unique (uuid; time stamp; ...)
     *                  format: format + time stamp
     *      3. Executes adding operation
     * @param customer
     */
    @Transactional(propagation = Propagation.REQUIRED)
    public void addCustomer(Customer customer) {
        checkCustomerParams(customer.getName(), customer.getFr(), customer.getPhone());
        AssertUtil.isTrue(customerMapper.queryCustomerByName(customer.getName()) != null, "The customer name already exists");
        customer.setIsValid(1);
        customer.setCreateDate(new Date());
        customer.setUpdateDate(new Date());
        customer.setState(0);
        String khno = "KH" + System.currentTimeMillis();
        customer.setKhno(khno);
        AssertUtil.isTrue(customerMapper.insertSelective(customer) != 1, "Adding customer failure");
    }

    private void checkCustomerParams(String name, String fr, String phone) {
        AssertUtil.isTrue(StringUtils.isBlank(name), "Customer name should not be empty");
        AssertUtil.isTrue(StringUtils.isBlank(fr), "The fr should not be empty");
        AssertUtil.isTrue(StringUtils.isBlank(phone), "Phone should not be empty");
        AssertUtil.isTrue(!PhoneUtil.isMobile(phone), "The phone format is not right");
    }

    /**
     * Adds customer
     *      1. Check parameters
     *          customerName -> Not null, unique
     *          fr -> Not null
     *          phone -> right format
     *          id -> Not null, data exist
     *      2. Set default value
     *          updateDate -> current system time
     *      3. Executes updating operation
     * @param customer
     */
    @Transactional(propagation = Propagation.REQUIRED)
    public void updateCustomer(Customer customer) {
        AssertUtil.isTrue(customer.getId() == null, "The data to be updated do not exist");
        Customer temp = customerMapper.selectByPrimaryKey(customer.getId());
        AssertUtil.isTrue(temp == null, "The customer to be updated does not exist");
        checkCustomerParams(customer.getName(), customer.getFr(), customer.getPhone());
        temp = customerMapper.queryCustomerByName(customer.getName());
        AssertUtil.isTrue(temp != null && !(temp.getId().equals(customer.getId())), "The customer name already exists");
        customer.setUpdateDate(new Date());
        AssertUtil.isTrue(customerMapper.updateByPrimaryKeySelective(customer) != 1, "Updating customer failed");
    }

    /**
     * Deletes the given customer
     *      1. Check parameters
     *          id -> Not null, data exist
     *      2. Sets default value
     *          isValid -> 0
     *          updateDate
     *      3. Executes the updating operation
     * @param id
     */
    @Transactional(propagation = Propagation.REQUIRED)
    public void deleteCustomer(Integer id) {
        Customer customer = customerMapper.selectByPrimaryKey(id);
        AssertUtil.isTrue(id == null || customer == null, "The data to be deleted do not exist");
        customer.setIsValid(0);
        customer.setUpdateDate(new Date());
        AssertUtil.isTrue(customerMapper.updateByPrimaryKeySelective(customer) != 1, "The deleting operation failed");
    }

    /**
     * Updates the customer loss state
     *         1. Check the customer data that is losing
     *         2. Batch adding these data to customer loss table
     *         3. Batch updating customer loss state
     */
    @Transactional(propagation = Propagation.REQUIRED)
    public void updateCustomerState() {
        List<Customer> lossCustomerList = customerMapper.queryLossCustomers();
        if (lossCustomerList != null && lossCustomerList.size() > 0) {
            List<Integer> lossCustomerIds = new ArrayList<>();
            List<CustomerLoss> customerLossList = new ArrayList<>();
            lossCustomerList.forEach(customer -> {
                CustomerLoss customerLoss = new CustomerLoss();
                customerLoss.setCreateDate(new Date());
                customerLoss.setCusManager(customer.getCusManager());
                customerLoss.setCusName(customer.getName());
                customerLoss.setCusNo(customer.getKhno());
                customerLoss.setIsValid(1);
                customerLoss.setUpdateDate(new Date());
                customerLoss.setState(0);
                CustomerOrder customerOrder = customerOrderMapper.queryLossCustomerOrderByCustomerId(customer.getId());
                if (customerOrder != null) {
                    customerLoss.setLastOrderTime(customerOrder.getOrderDate());
                }
                customerLossList.add(customerLoss);
                lossCustomerIds.add(customer.getId());
            });
            AssertUtil.isTrue(customerLossMapper.insertBatch(customerLossList) != customerLossList.size(), "The loss customer transferring failed");
            AssertUtil.isTrue(customerMapper.updateCustomerStateByIds(lossCustomerIds) != lossCustomerIds.size(), "The loss customer transferring failed");
        }
    }

    /**
     * Query the customer contribution total analysis
     * @param customerQuery
     * @return
     */
    public Map<String, Object> queryCustomerContributionByParams(CustomerQuery customerQuery) {
        Map<String, Object> map = new HashMap<>();

        // Starts paging
        PageHelper.startPage(customerQuery.getPage(), customerQuery.getLimit());
        // Gets correspondent page object
        PageInfo<Map<String, Object>> pageInfo = new PageInfo<>(customerMapper.queryCustomerContributionByParams(customerQuery));

        map.put("code", 0);
        map.put("msg", "success");
        map.put("count", pageInfo.getTotal());
        map.put("data", pageInfo.getList());

        return map;
    }

    /**
     * Query the make up of customer (line chart)
     * @return
     */
    public Map<String, Object> countCustomerMakeup() {
        Map<String, Object> map = new HashMap<>();
        List<Map<String, Object>> dataList = customerMapper.countCustomerMakeup();
        List<String> xAxis= new ArrayList<>();
        List<Integer> yAxis = new ArrayList<>();
        if (dataList != null && dataList.size() > 0) {
            for (int i = 0; i < dataList.size(); i++) {
                Map<String, Object> data = dataList.get(i);
                xAxis.add(data.get("level").toString());
                yAxis.add(Integer.parseInt(data.get("total").toString()));
            }
        }
        map.put("xAxis", xAxis);
        map.put("yAxis", yAxis);
        return map;
    }

    /**
     * Query the make up of customer (pie chart)
     * @return
     */
    public Map<String, Object> countCustomerMakeup02() {
        Map<String, Object> map = new HashMap<>();
        List<Map<String, Object>> dataList = customerMapper.countCustomerMakeup();
        List<String> xAxis= new ArrayList<>();
        List<Map<String, Object>> yAxis = new ArrayList<>();

        if (dataList != null && dataList.size() > 0) {
            dataList.forEach(m -> {
                xAxis.add(m.get("level").toString());
                Map<String, Object> dataMap = new HashMap<>();
                dataMap.put("name", m.get("level"));
                dataMap.put("value", m.get("total"));
                yAxis.add(dataMap);
            });
        }

        map.put("xAxis", xAxis);
        map.put("yAxis", yAxis);
        return map;
    }
}
